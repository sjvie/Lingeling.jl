var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#General","page":"API Reference","title":"General","text":"","category":"section"},{"location":"api/#Lingeling.LglPtr","page":"API Reference","title":"Lingeling.LglPtr","text":"LglPtr\n\nWrapper for the Lingeling solver. The object is fully managed by the Lingeling C library but the memory should be released manually using lgl_release.\n\nFields\n\nptr::Ptr{Cvoid}: The pointer to the Lingeling solver.\n\n\n\n\n\n","category":"type"},{"location":"api/#Lingeling.lgl_version-Tuple{}","page":"API Reference","title":"Lingeling.lgl_version","text":"lgl_version()::String\n\nReturn the version of the Lingeling SAT-Solver.\n\nReturns\n\nversion::String: The version of the Lingeling SAT-Solver as a Julia string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lingeling.lgl_init-Tuple{}","page":"API Reference","title":"Lingeling.lgl_init","text":"lgl_init()::LglPtr\n\nInitialize (construct) the Lingeling SAT-Solver.\n\nReturns\n\nsolver::LglPtr: A pointer to the Lingeling SAT-Solver.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lingeling.lgl_release-Tuple{LglPtr}","page":"API Reference","title":"Lingeling.lgl_release","text":"lgl_release(solver::LglPtr)\n\nDestruct the Lingeling SAT-Solver.\n\nArguments\n\nsolver::LglPtr: A pointer to the Lingeling SAT-Solver.\n\n\n\n\n\n","category":"method"},{"location":"api/#Options","page":"API Reference","title":"Options","text":"","category":"section"},{"location":"api/#Lingeling.lgl_setopt-Tuple{LglPtr, String, Integer}","page":"API Reference","title":"Lingeling.lgl_setopt","text":"lgl_setopt(solver::LglPtr, opt::String, val::Integer)\n\nSet an option value.\n\nArguments\n\nsolver::LglPtr: A pointer to the Lingeling SAT-Solver.\nopt::String: The option name.\nval::Integer: The new option value.\n\nThrows\n\nInexactError: If the option value can not be converted to a Cint.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lingeling.lgl_getopt-Tuple{LglPtr, String}","page":"API Reference","title":"Lingeling.lgl_getopt","text":"lgl_getopt(solver::LglPtr, opt::String)::Cint\n\nGet the current option value.\n\nArguments\n\nsolver::LglPtr: A pointer to the Lingeling SAT-Solver.\nopt::String: The option name.\n\nReturns\n\nval::Cint: The option value for the given option.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lingeling.lgl_defopt-Tuple{LglPtr, String}","page":"API Reference","title":"Lingeling.lgl_defopt","text":"lgl_defopt(solver::LglPtr, opt::String)::Cint\n\nGet the default option value.\n\nArguments\n\nsolver::LglPtr: A pointer to the Lingeling SAT-Solver.\nopt::String: The option name.\n\nReturns\n\nval::Cint: The default option value for the given option.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lingeling.lgl_hasopt-Tuple{LglPtr, String}","page":"API Reference","title":"Lingeling.lgl_hasopt","text":"lgl_hasopt(solver::LglPtr, opt::String)::Cint\n\nCheck whether an option exists.\n\nArguments\n\nsolver::LglPtr: A pointer to the Lingeling SAT-Solver.\nopt::String: The option name.\n\nReturns\n\nval::Cint: Whether the option exists. 1 if it exists, 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Solving","page":"API Reference","title":"Solving","text":"","category":"section"},{"location":"api/#Lingeling.lgl_add-Tuple{LglPtr, Integer}","page":"API Reference","title":"Lingeling.lgl_add","text":"lgl_add(solver::LglPtr, lit::Integer)\n\nAdd a literal of the next clause.  A 0 literal terminates the clause.\n\nArguments\n\nsolver::LglPtr: A pointer to the Lingeling SAT-Solver.\nlit::Cint: The literal to add. A 0 literal terminates the clause. Negative literals are negated (i.e., -2 means \"NOT 2\")\n\nThrows\n\nInexactError: If the literal can not be converted to a Cint.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lingeling.lgl_sat-Tuple{LglPtr}","page":"API Reference","title":"Lingeling.lgl_sat","text":"lgl_sat(solver::LglPtr)::Cint\n\nCall the main SAT routine. The return values are as above, e.g. Lingeling.UNSATISFIABLE, Lingeling.SATISFIABLE, or Lingeling.UNKNOWN.\n\nArguments\n\nsolver::LglPtr: A pointer to the Lingeling SAT-Solver.\n\nReturns\n\nval::Cint: The result of the SAT routine. (e.g. Lingeling.UNSATISFIABLE, \n\nLingeling.SATISFIABLE, or Lingeling.UNKNOWN)\n\n\n\n\n\n","category":"method"},{"location":"api/#Lingeling.UNKNOWN","page":"API Reference","title":"Lingeling.UNKNOWN","text":"Return code meaning unknown result.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Lingeling.SATISFIABLE","page":"API Reference","title":"Lingeling.SATISFIABLE","text":"Return code meaning the formula is satisfiable.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Lingeling.UNSATISFIABLE","page":"API Reference","title":"Lingeling.UNSATISFIABLE","text":"Return code meaning the formula is unsatisfiable.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Lingeling.lgl_deref-Tuple{LglPtr, Integer}","page":"API Reference","title":"Lingeling.lgl_deref","text":"lgl_deref(solver::LglPtr, lit::Integer)::Cint\n\nAfter 'lgl_sat' was called and returned Lingeling.SATISFIABLE, then the satisfying assignment can be obtained by 'dereferencing' literals. The value of the literal is return as 1 for true,  -1 for false and 0 for an unknown value.\n\nArguments\n\nsolver::LglPtr: A pointer to the Lingeling SAT-Solver.\nlit::Integer: The literal to dereference.\n\nReturns\n\nval::Cint: The value of the literal. 1 for true, -1 for false, 0 for unknown.\n\nThrows\n\nInexactError: If the literal can not be converted to a Cint.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lingeling.lgl_freeze-Tuple{LglPtr, Integer}","page":"API Reference","title":"Lingeling.lgl_freeze","text":"lgl_freeze(solver::LglPtr, lit::Integer)\n\nFreeze a literal meaning that it will not be eliminated during lgl_sat so it can be used in future calls to lgl_add.\n\nArguments\n\nsolver::LglPtr: A pointer to the Lingeling SAT-Solver.\nlit::Integer: The literal to freeze.\n\nThrows\n\nInexactError: If the literal can not be converted to a Cint.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lingeling.lgl_frozen-Tuple{LglPtr, Integer}","page":"API Reference","title":"Lingeling.lgl_frozen","text":"lgl_frozen(solver::LglPtr, lit::Integer)::Cint\n\nCheck whether a literal is frozen.\n\nArguments\n\nsolver::LglPtr: A pointer to the Lingeling SAT-Solver.\nlit::Integer: The literal to check.\n\nReturns\n\nval::Cint: Whether the literal is frozen. 1 if it is frozen, 0 otherwise.\n\nThrows\n\nInexactError: If the literal can not be converted to a Cint.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lingeling.lgl_melt-Tuple{LglPtr, Integer}","page":"API Reference","title":"Lingeling.lgl_melt","text":"lgl_melt(solver::LglPtr, lit::Integer)\n\nMelt a literal meaning that it may be eliminated during lgl_sat.\n\nArguments\n\nsolver::LglPtr: A pointer to the Lingeling SAT-Solver.\nlit::Integer: The literal to melt.\n\nThrows\n\nInexactError: If the literal can not be converted to a Cint.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lingeling.lgl_meltall-Tuple{LglPtr}","page":"API Reference","title":"Lingeling.lgl_meltall","text":"lgl_meltall(solver::LglPtr)\n\nMelt all literals.\n\nArguments\n\nsolver::LglPtr: A pointer to the Lingeling SAT-Solver.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lingeling.lgl_usable-Tuple{LglPtr, Integer}","page":"API Reference","title":"Lingeling.lgl_usable","text":"lgl_usable(solver::LglPtr, lit::Integer)::Cint\n\nCheck whether a literal is usable. A literal becomes unusable if it was not frozen during the last call to lgl_sat. Being unusable means that the literal is not allowed to be used in the next call to lgl_add.\n\nArguments\n\nsolver::LglPtr: A pointer to the Lingeling SAT-Solver.\nlit::Integer: The literal to check.\n\nReturns\n\nval::Cint: Whether the literal is usable. 1 if it is usable, 0 otherwise.\n\nThrows\n\nInexactError: If the literal can not be converted to a Cint.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lingeling.lgl_reusable-Tuple{LglPtr, Integer}","page":"API Reference","title":"Lingeling.lgl_reusable","text":"lgl_reusable(solver::LglPtr, lit::Integer)::Cint\n\nCheck whether a literal is reusable. A literal may not have been frozen during the last call to lgl_sat but could still be reusable (and thus be made usable again using lgl_reuse).\n\nArguments\n\nsolver::LglPtr: A pointer to the Lingeling SAT-Solver.\nlit::Integer: The literal to check.\n\nReturns\n\nval::Cint: Whether the literal is reusable. 1 if it is reusable, 0 otherwise.\n\nThrows\n\nInexactError: If the literal can not be converted to a Cint.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lingeling.lgl_reuse-Tuple{LglPtr, Integer}","page":"API Reference","title":"Lingeling.lgl_reuse","text":"lgl_reuse(solver::LglPtr, lit::Integer)\n\nMake a literal usable again. If a literal was not frozen during the last call to lgl_sat but is reusable, it can be made usable again using this function.\n\nArguments\n\nsolver::LglPtr: A pointer to the Lingeling SAT-Solver.\nlit::Integer: The literal to make reusable again.\n\nThrows\n\nInexactError: If the literal can not be converted to a Cint.\n\n\n\n\n\n","category":"method"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Lingeling.jl can be installed using","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"]add Lingeling","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"or","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"Lingeling\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"You can test whether the installation was successful by running","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Lingeling\nlgl_version()","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"which should print the current version of Lingeling.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"compat: Windows support\nLingeling.jl does currently not work on Windows.","category":"page"},{"location":"#Lingeling.jl-Documentation","page":"Home","title":"Lingeling.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is Lingeling.jl, a Julia package providing an interface to the SAT solver Lingeling created by Armin Biere (Website, Repo).","category":"page"},{"location":"","page":"Home","title":"Home","text":"compat: Windows support\nLingeling.jl does currently not work on Windows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"While supporting the most important functions of Lingeling, this package does not include access to the full Lingeling API. For any functionality beyond what is provided here, please call the Lingeling C API directly using Lingeling_jll. For reference, see the Lingeling.jl source code.","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"installation.md\", \"example.md\", \"api.md\"]\nDepth = 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Tip\nSome additional information may also be found in the Lingeling header file, as well as in the PicoSAT header file.","category":"page"},{"location":"example/#A-Short-Example","page":"Example","title":"A Short Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"First, install Lingeling.jl using the instructions in the installation guide.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Check the installation by printing the version of Lingeling:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using Lingeling\nlgl_version()","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Next, we will initialize an instance of Lingeling and add a clause to it:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"solver = lgl_init()\nlgl_add(solver, 1)\nlgl_add(solver, 2)\nlgl_add(solver, 0)  # end of clause","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The lgl_add function is used to add literals to the clause. Literals are represented as integers, where positive integers represent the literal itself and negative integers represent the negation of the literal. Adding a 0 ends the current clause.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In this case, we are adding two literals (1 land 2) followed by a terminating zero. Let's add another clause:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"lgl_add(solver, 1)\nlgl_add(solver, -2)\nlgl_add(solver, 0)  # end of clause","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This adds a second clause (1 land neg 2). The full formula we have now is:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(1 lor 2) land (1 lor neg 2)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Now, we can tell Lingeling to solve the formula (i.e., find a satisfying assignment):","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"result_code = lgl_sat(solver)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The lgl_sat function will return a result code indicating whether the formula is satisfiable or not. The possible return values are Lingeling.SATISFIABLE, Lingeling.UNSATISFIABLE, or Lingeling.UNKNOWN.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"println(\"Satisfiable: \", result_code == Lingeling.SATISFIABLE)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"To get the satisfying assignments, we can check the values of each literal:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"println(\"Literal 1: \", lgl_deref(solver, 1))\nprintln(\"Literal 2: \", lgl_deref(solver, 2))","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Finally, we should release the solver instance to free up resources:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"lgl_release(solver)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"info: Full Example Code\nThe full code for this example can also be found here","category":"page"}]
}
